using System;
using System.Diagnostics;
using System.IO;

namespace PChecker.Random
{

    /// <summary>
    /// This class implements a JQF-style stream-based input generator.
    /// See more: https://github.com/rohanpadhye/JQF
    /// </summary>
    public class StreamBasedValueGenerator : IRandomValueGenerator
    {
        /// <summary>
        /// Device for generating random numbers.
        /// </summary>
        private readonly System.Random _random;

        private readonly MemoryStream _bytes = new();

        public byte[] GetBytesCopy()
        {
            long pos = _bytes.Position;
            _bytes.Position = 0;
            byte[] output = new byte[_bytes.Length];
            Debug.Assert(_bytes.Read(output) == _bytes.Length);
            return output;
        }


        public uint Seed { get; set; }

        /// <summary>
        /// Create a stream based value generator with a random device as well
        /// as a pre-defined byte stream.
        /// </summary>
        /// <param name="random">The random device used to generate random values.</param>
        /// <param name="bytes">An optional pre-defined byte stream.</param>
        public StreamBasedValueGenerator(System.Random random, MemoryStream? bytes)
        {
            _random = random;
            if (bytes != null)
            {
                // Reset the pos.
                bytes.Position = 0;
                bytes.CopyTo(_bytes);
                // When a new stream is created we want to read from beginning.
                _bytes.Position = 0;
            }
        }


        /// <summary>
        /// Create a stream based value generator using CheckerConfiguration.
        /// </summary>
        /// <param name="checkerConfiguration"></param>
        public StreamBasedValueGenerator(CheckerConfiguration checkerConfiguration):
            this(new System.Random((int?)checkerConfiguration.RandomGeneratorSeed ?? Guid.NewGuid().GetHashCode()), null)
        {
        }

        /// <summary>
        /// Create a default stream based value generator.
        /// </summary>
        public StreamBasedValueGenerator():
            this(new System.Random(Guid.NewGuid().GetHashCode()), null)
        {
        }


        /// <summary>
        /// Create a stream based value generator with an existing generator.
        /// </summary>
        /// <param name="other"></param>
        public StreamBasedValueGenerator(StreamBasedValueGenerator other) : this(other._random, other._bytes)
        {
        }

        /// <summary>
        /// Returns a non-negative random number.
        /// </summary>
        public int Next()
        {
            long missingBytes = sizeof(int) - (_bytes.Length - _bytes.Position);
            // Make sure the buffer has enough bytes to read.
            if (missingBytes > 0)
            {
                AppendBytes(missingBytes);
            }
            var reader = new BinaryReader(_bytes);
            int value = reader.ReadInt32();
            if (value < 0)
            {
                value += int.MaxValue;
            }
            return value;
        }


        /// <summary>
        /// Returns a non-negative random number less than the specified max value.
        /// </summary>
        /// <param name="maxValue">Exclusive upper bound.</param>
        public int Next(int maxValue)
        {
            return Next() % maxValue;
        }

        /// <summary>
        /// Returns a random floating-point number that is greater
        /// than or equal to 0.0, and less than 1.0.
        /// </summary>
        public double NextDouble()
        {
            long missingBytes = sizeof(double) - (_bytes.Length - _bytes.Position);
            // Make sure the buffer has enough bytes to read.
            if (missingBytes > 0)
            {
                AppendBytes(missingBytes);
            }
            var reader = new BinaryReader(_bytes);
            return reader.ReadDouble();
        }

        /// <summary>
        /// Add missing bytes to the underlying byte stream.
        /// This Method automatically reset the position pointer so that
        /// the MemoryStream will read the new generated bytes.
        /// </summary>
        /// <param name="size"> Number of bytes to be generated. </param>
        private void AppendBytes(long size)
        {
            var originPosition = _bytes.Position;
            byte[] newBytes = new byte[size];
            _random.NextBytes(newBytes);
            _bytes.Write(newBytes);
            _bytes.Position = originPosition;

        }

        /// <summary>
        /// Save byte stream to file.
        /// </summary>
        /// <param name="path">Path of the file.</param>
        public void SaveToFile(string path)
        {
            _bytes.WriteTo(new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write));
        }
    }
}